#include <memory> // для работы с умными указателями
#include <thread> // для работы с многопоточностью

namespace cpp11 {

	namespace auto_cpp {
		// auto позволяет компилятопру автоматически выводить тип переменной, благодаря чему код становиться чище и компактнее.
		// Ещё auto делает код менее подверженным ошибкам, если тип контейнера изменится, код с auto автоматически подстроится.	

		std::map<int, std::vector<std::string>>::iterator it = my_map.begin();  // До
		auto it = my_map.begin();												// После
	}


	namespace smart_pointers {
		// Умные указатели устраняют необходимость вручную управляет памятью с помощью операторов new и delete.
		// Предовращает утечку памяти и ошибки двойного освобождения (double free).

		int* p = new int(10);					// До
		delete p;

		auto p = std::make_shared<int>(10);		// После
	}

	namespace lambda_cpp {
		// Лямбды в c++ - это анонимные функции, которые можно определять прямо на месте.
		// Лямбды упрощают код, улучшают читаемость и упрощают работу с алгоритмами стандартной библиотеки.

		// До C++11 приходилось создавать отдельные функции или использовать функциональные объекты:
		struct Comparator {
			bool operator()(int a, int b) { return a < b; }
		};
		std::sort(v.begin(), v.end(), Comparator());

		//Код после:
		std::sort(v.begin(), v.end(), [](int a, int b) { return a < b; });
	}

	namespace rvalue_reference {
		// Семантика перемещения позволяет передать владения ресурсами от одного объекта другому при помощи функции std::move.
		// Rvalue-ссылки (T&&) используются для реализации конструктора и оператора перемещения.
		// Это повышает производительность. Копирование больших объектов затратно, так как приходится дублировать память.
		// С std::move данные просто перемещаются, вместо создания их копии.

		std::string str = "Hello";
		std::string copy = str;  // Копирование данных
		//
		std::string str = "Hello";
		std::string moved = std::move(str);  // Перемещение, экономия ресурсов
	}

	namespace constexpr_cpp {
		// constexpr позволяет вычислять значение на этапе компиляции, а не во время выполнения кода.
		// Это оптимизирует код. Вы можете вычислить значение значение сложных выражений один раз во время компиляции, вместо повторного вычисления в рантайме.

		const int size = 10 * 20;	   // Вычисление на этапе компиляции не гарантировано

		constexpr int size = 10 * 20;  // Гарантированное вычисление на этапе компиляции

	}

	namespace thread_lyb {
		// thread - библиотека предоставляющая инструменты для создания потоков, синхронизации и атомарных операций.
		// Обеспечивает стандартизированный способ работы с многопоточностью. Устраняет разрозненность подходов к многопоточности на разных платформах

		std::thread t([]() { std::cout << "Hello from thread!"; });
		t.join();

	}

	namespace uniform_init {
		// Унифицированная инициализация - это единый синтаксис для инициализации объектов.
		// Упрощает инициализацию объектов, устраняет неоднозначности при инициализации и упрощает код.

		std::vector<int> v;					// До
		v.push_back(1);
		v.push_back(2);
		v.push_back(3);

		std::vector<int> v = { 1, 2, 3 };	// После
	}

	namespace enum_class {
		// Это объявление перечислений, которые не допускают неявного преоброзования в целочисленные типы.
		// Повышает безопасность кода. Обычные перечисления могут приводить к неожиданным ошибкам:
		enum Color { Red, Green };
		int value = Red;  // Возможно
		
		// При использовании enum class, такое сделать невозможно:
		enum class Color { Red, Green };
		Color c = Color::Red;  // Неявного преобразования в int больше нет
	}

	namespace nullptr_cpp {
		// Литерал для обозначения нулевого указателя, использует тип nullptr_t
		// Исключает неоднозначносмть между указателем и целочисленным значением 0, благодаря чему улучшается читаемость и безопасность кода:
		void foo(int);
		void foo(int*);

		foo(0);			// Какую перегрузку вызывать?
		foo(nullptr);   // Однозначно вызывает foo(int*)
	}

}